# [BOJ] 10711 - 모래성

### 문제 바로가기

>  https://www.acmicpc.net/problem/10711 

### 알고리즘

> - 

### 문제 풀이 및 주의

> #### 1차 시간초과
>
> ```
> - 바다인 노드를 돌며 주변 모래성에 영향을 줌
> - 만약 모래성이면서 자신의 강도 보다 주변의 바다가 많다면 V VECTOR에 넣는다
> - v 벡터를 돌며 모래성을 부수고 남은 모래 VECTOR를 돌며 확인한다
> ```
>
> 단순하게 구현하면 1000*1000 크기의 맵을 1000번 확인하는 구현이 있어 이는 O(1000^3) 이므로 시간 초과가 발생한다(?)
>
> 모래성을 찾는것 w*h (1000 * 1000) 여기에 만약 1000000개의 모래성이 있다면 ?
>
> 1초->1억 1000000000

> #### 2차 시간초과 - 방문체크로 해결
>
> ```
> - 맵을 돌며 자신의 강도보다 인접한 바다의 수가 같거나 큰 노드를 Q 에 저장한다
> - Q 에 대해 모래성을 부순다
> - Q 기준 기준으로 주위 8방향의 모래성에 영향을 끼친다 (부숴진 부분은 바다가 되기 때문에)
> 8방 노드 중에 부숴지는 조건에 부합된다면 해당 노드를 nq 에 저장한다. 저장 된것은 visited[x][y]=1로 체크
> - q=nq . ans++ 을 수행한다
> ```
>
> 시간초과 - 방문체크를 안해줘서이다!
>
> 방문체크를 하지 않을 경우 nQ에 두번 들어가게 된다. 
>
> 이렇게 되면 중복하여 점점 더 많은 것들을 체크해줘야 해서 시간 초과발생하는 것이다.

> #### 3차 답안 참고
>
>   1차 방법, 모든 맵을 탐색하면서 파도가 한번 칠 때 마다 그 파도에 의해 부서지는 모래성을 표시해주는 과정을 더이상 모래성의 형태가 변하지 않을 때까지 반복하는 것은 맵의 크기가 너무 커서 시간초과의 원인이 된다.
>
> 따라서 파도가  칠때마다 매번 모든 맵을 탐색하지 않는 다른 방법을 생각한다.
>
> 이 방법은 모래성이 아닌. 모래를 기준으로 접근
>
> ![<10711모래성3>](https://github.com/hyojin38/Algorithm-code/blob/main/BOJ-Code/10711-모래성/10711.jpg)

